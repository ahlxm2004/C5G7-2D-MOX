#ifndef _C5G72D_SN_FRAME_H_
#define _C5G72D_SN_FRAME_H_ 

#include "basic.hpp"
#include "discrete_directions_coefficients.hpp"
#include <cassert>
#include <string>
#include <tuple>

namespace C5G72D_sn_frame {
	/*
		0 : UO2 Fuel
		1 : 4.3% MOX Fuel
		2 : 7.0% MOX Fuel
		3 : 8.7% MOX Fuel
		4 : Fission Chamber
		5 : Guide Tube
		6 : Moderator (water)
	*/

	const int G = 7; // energy groups
	const int R = 7; // region types 

	const double LenX = 64.26, LenY = 64.26;
	const double cell_length = 1.26, cell_diameter = 1.08;

	const double sigma_t[R][G] = { // use transport cross-section INSTEAD OF total cross-section
		{1.77949E-01, 3.29805E-01, 4.80388E-01, 5.54367E-01, 3.11801E-01, 3.95168E-01, 5.64406E-01},
		{1.78731E-01, 3.30849E-01, 4.83772E-01, 5.66922E-01, 4.26227E-01, 6.78997E-01, 6.82852E-01},
		{1.81323E-01, 3.34368E-01, 4.93785E-01, 5.91216E-01, 4.74198E-01, 8.33601E-01, 8.53603E-01},
		{1.83045E-01, 3.36705E-01, 5.00507E-01, 6.06174E-01, 5.02754E-01, 9.21028E-01, 9.55231E-01},
		{1.26032E-01, 2.93160E-01, 2.84250E-01, 2.81020E-01, 3.34460E-01, 5.65640E-01, 1.17214E+00},
		{1.26032E-01, 2.93160E-01, 2.84240E-01, 2.80960E-01, 3.34440E-01, 5.65640E-01, 1.17215E+00},
		{1.59206E-01, 4.12970E-01, 5.90310E-01, 5.84350E-01, 7.18000E-01, 1.25445E+00, 2.65038E+00}
	};

	const double sigma_f[R][G] = {
		{7.21206E-03, 8.19301E-04, 6.45320E-03, 1.85648E-02, 1.78084E-02, 8.30348E-02, 2.16004E-01},
		{7.62704E-03, 8.76898E-04, 5.69835E-03, 2.28872E-02, 1.07635E-02, 2.32757E-01, 2.48968E-01},
		{8.25446E-03, 1.32565E-03, 8.42156E-03, 3.28730E-02, 1.59636E-02, 3.23794E-01, 3.62803E-01},
		{8.67209E-03, 1.62426E-03, 1.02716E-02, 3.90447E-02, 1.92576E-02, 3.74888E-01, 4.30599E-01},
		{4.79002E-09, 5.82564E-09, 4.63719E-07, 5.24406E-06, 1.45390E-07, 7.14972E-07, 2.08041E-06},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00}
	};

	const double nu[R][G] = {
		{2.78145E+00, 2.47443E+00, 2.43383E+00, 2.43380E+00, 2.43380E+00, 2.43380E+00, 2.43380E+00},
		{2.85209E+00, 2.89099E+00, 2.85486E+00, 2.86073E+00, 2.85447E+00, 2.86415E+00, 2.86780E+00},
		{2.88498E+00, 2.91079E+00, 2.86574E+00, 2.87063E+00, 2.86714E+00, 2.86658E+00, 2.87539E+00},
		{2.90426E+00, 2.91795E+00, 2.86986E+00, 2.87491E+00, 2.87175E+00, 2.86752E+00, 2.87808E+00},
		{2.76283E+00, 2.46239E+00, 2.43380E+00, 2.43380E+00, 2.43380E+00, 2.43380E+00, 2.43380E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00}
	};

	const double chi[G] =
		{5.87910E-01, 4.11760E-01, 3.39060E-04, 1.17610E-07, 0.00000E+00, 0.00000E+00, 0.00000E+00};

	const double sigma_s[R][G][G] = {
	 {
		{1.27537E-01, 4.23780E-02, 9.43740E-06, 5.51630E-09, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 3.24456E-01, 1.63140E-03, 3.14270E-09, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 4.50940E-01, 2.67920E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 4.52565E-01, 5.56640E-03, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 1.25250E-04, 2.71401E-01, 1.02550E-02, 1.00210E-08},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.29680E-03, 2.65802E-01, 1.68090E-02},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 8.54580E-03, 2.73080E-01}
	 },
	 {
		{1.28876E-01, 4.14130E-02, 8.22900E-06, 5.04050E-09, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 3.25452E-01, 1.63950E-03, 1.59820E-09, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 4.53188E-01, 2.61420E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 4.57173E-01, 5.53940E-03, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 1.60460E-04, 2.76814E-01, 9.31270E-03, 9.16560E-09},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.00510E-03, 2.52962E-01, 1.48500E-02},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 8.49480E-03, 2.65007E-01}
	 },
	 {
		{1.30457E-01, 4.17920E-02, 8.51050E-06, 5.13290E-09, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 3.28428E-01, 1.64360E-03, 2.20170E-09, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 4.58371E-01, 2.53310E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 4.63709E-01, 5.47660E-03, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 1.76190E-04, 2.82313E-01, 8.72890E-03, 9.00160E-09},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.27600E-03, 2.49751E-01, 1.31140E-02},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 8.86450E-03, 2.59529E-01}
	 },
	 {
		{1.31504E-01, 4.20460E-02, 8.69720E-06, 5.19380E-09, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 3.30403E-01, 1.64630E-03, 2.60060E-09, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 4.61792E-01, 2.47490E-03, 0.00000E+00, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 4.68021E-01, 5.43300E-03, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 1.85970E-04, 2.85771E-01, 8.39730E-03, 8.92800E-09},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.39160E-03, 2.47614E-01, 1.23220E-02},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 8.96810E-03, 2.56093E-01}
	 },
	 {
		{6.61659E-02, 5.90700E-02, 2.83340E-04, 1.46220E-06, 2.06420E-08, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 2.40377E-01, 5.24350E-02, 2.49900E-04, 1.92390E-05, 2.98750E-06, 4.21400E-07},
		{0.00000E+00, 0.00000E+00, 1.83425E-01, 9.22880E-02, 6.93650E-03, 1.07900E-03, 2.05430E-04},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 7.90769E-02, 1.69990E-01, 2.58600E-02, 4.92560E-03},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 3.73400E-05, 9.97570E-02, 2.06790E-01, 2.44780E-02},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 9.17420E-04, 3.16774E-01, 2.38760E-01},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 4.97930E-02, 1.09910E+00}
	 },
	 {
		{6.61659E-02, 5.90700E-02, 2.83340E-04, 1.46220E-06, 2.06420E-08, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 2.40377E-01, 5.24350E-02, 2.49900E-04, 1.92390E-05, 2.98750E-06, 4.21400E-07},
		{0.00000E+00, 0.00000E+00, 1.83297E-01, 9.23970E-02, 6.94460E-03, 1.08030E-03, 2.05670E-04},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 7.88511E-02, 1.70140E-01, 2.58810E-02, 4.92970E-03},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 3.73330E-05, 9.97372E-02, 2.06790E-01, 2.44780E-02},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 9.17260E-04, 3.16765E-01, 2.38770E-01},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 4.97920E-02, 1.09912E+00}
	 },
	 {
		{4.44777E-02, 1.13400E-01, 7.23470E-04, 3.74990E-06, 5.31840E-08, 0.00000E+00, 0.00000E+00},
		{0.00000E+00, 2.82334E-01, 1.29940E-01, 6.23400E-04, 4.80020E-05, 7.44860E-06, 1.04550E-06},
		{0.00000E+00, 0.00000E+00, 3.45256E-01, 2.24570E-01, 1.69990E-02, 2.64430E-03, 5.03440E-04},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 9.10284E-02, 4.15510E-01, 6.37320E-02, 1.21390E-02},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 7.14370E-05, 1.39138E-01, 5.11820E-01, 6.12290E-02},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 2.21570E-03, 6.99913E-01, 5.37320E-01},
		{0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 0.00000E+00, 1.32440E-01, 2.48070E+00}
	 }
	};

	int Nx, Ny, Ng, Nd, ND;

	std::vector <std::vector <short> > block;
	std::vector <double> dx, dy;
	std::vector <double> center_x, center_y;

	vector_double_2d direction_data;

	int id(int x, int y) {return x * Ny + y;}
	int id(int g, int x, int y) {return g * Ng + x * Ny + y;}

	void read_circle_geo(std::vector <double> &l,
	 std::vector <std::vector <bool> > &b, int n) {
		l.resize(n);
		b = std::vector <std::vector <bool> > (n, std::vector <bool> (n));
		for (int i = 0; i < n; i++)
			std::ignore = scanf("%lf", &l[i]);
		std::vector <double> sum_l(n);
		std::partial_sum(l.begin(), l.end(), sum_l.begin());
		assert(std::fabs(sum_l.back() - cell_length) < 1e-6);
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++) {
				double u = sum_l[i] - l[i] / 2 - cell_length / 2;
				double v = sum_l[j] - l[j] / 2 - cell_length / 2;
				b[i][j] = (u * u + v * v < cell_diameter * cell_diameter / 4);
				printf("%d%c", (int)b[i][j], j + 1 == n ? '\n' : ' ');
			}
	}

	void init(int cx, int cy, int n) {
		assert(cx == cy);

		static const int T = 3; // x, y region
		static const int R = 2; // x, y non-uniform region
		static const int L = 17;

		static const int moderator_id = 6;
		static const int fission_chamber_id = 4;
		static const int guide_tube_id = 5;

		static const int overall[T][T] = {
			{0, 1, 2},
			{1, 0, 2},
			{2, 2, 2}
		};

		static const int UO2_assembly[L][L] = {
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0},
			{0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 5, 0, 0, 5, 0, 0, 4, 0, 0, 5, 0, 0, 5, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0},
			{0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
		};

		static const int MOX_assembly[L][L] = {
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1},
			{1, 2, 2, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2, 2, 1},
			{1, 2, 2, 5, 2, 3, 3, 3, 3, 3, 3, 3, 2, 5, 2, 2, 1},
			{1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1},
			{1, 2, 5, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 5, 2, 1},
			{1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1},
			{1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1},
			{1, 2, 5, 3, 3, 5, 3, 3, 4, 3, 3, 5, 3, 3, 5, 2, 1},
			{1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1},
			{1, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1},
			{1, 2, 5, 3, 3, 5, 3, 3, 5, 3, 3, 5, 3, 3, 5, 2, 1},
			{1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1},
			{1, 2, 2, 5, 2, 3, 3, 3, 3, 3, 3, 3, 2, 5, 2, 2, 1},
			{1, 2, 2, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2, 2, 1},
			{1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1},
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}
		};

		Nx = T * L * cx, Ny = T * L * cy; Ng = Nx * Ny;

		dx.resize(Nx), center_x.resize(Nx);
		std::vector <double> l0;
		std::vector <std::vector <bool> > b0;
		read_circle_geo(l0, b0, cx);
		for (int i = 0; i < R * L * cx; i++) dx[i] = l0[i % cx];
		for (int i = R * L * cx; i < Nx; i++)
			dx[i] = cell_length / cx;
		for (int i = 0; i < Nx; i++) {
			if (i % cx == 0) center_x[i] = cell_length * (i / cx);
			else center_x[i] = center_x[i - 1] + dx[i - 1] / 2;
			center_x[i] += dx[i] / 2;
		}
		dy = dx, center_y = center_x;

		block = std::vector <std::vector <short> > (Nx, std::vector <short> (Ny));

		for (int i = 0; i < Nx; i++)
			for (int j = 0; j < Ny; j++) {
				int ib1 = i / (L * cx), ib2 = i % (L * cx) / cx, ib3 = i % cx;
				int jb1 = j / (L * cy), jb2 = j % (L * cy) / cy, jb3 = j % cy;
				switch (overall[ib1][jb1]) {
					case 0: block[i][j] = (b0[ib3][jb3] ? UO2_assembly[ib2][jb2] : moderator_id); break;
					case 1: block[i][j] = (b0[ib3][jb3] ? MOX_assembly[ib2][jb2] : moderator_id); break;
					case 2: block[i][j] = moderator_id; break;
				}
			}

		Nd = n, ND = n * (n + 2) / 2;
		direction_data = get_discrete_directions_coefficients(n);
	}
}

#endif

